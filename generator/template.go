/**
 *  Copyright 2014 Paul Querna
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 *
 */

package generator

import (
	"bytes"
	"errors"
	"io/ioutil"
	"os"
	"os/exec"
	"text/template"
)

const ffjsonTemplate = `
// DO NOT EDIT!
// Code generated by ffjson <https://github.com/pquerna/ffjson>
// source: {{.InputPath}}
// DO NOT EDIT!

package {{.PackageName}}

import (
	"bytes"
	"encoding/json"
)

{{.Source}}
`

type templateInfo struct {
	InputPath   string
	PackageName string
	Source      string
}

func RenderTemplate(inputPath string, packageName string, source []byte) ([]byte, error) {
	var keep = false
	f, err := ioutil.TempFile("", "ffjson-fmt")
	if err != nil {
		return nil, err
	}
	defer func() {
		if !keep {
			os.Remove(f.Name())
		}
	}()

	t := template.Must(template.New("ffjson.go").Parse(ffjsonTemplate))
	err = t.Execute(f, &templateInfo{
		InputPath:   inputPath,
		PackageName: packageName,
		Source:      string(source),
	})
	if err != nil {
		return nil, err
	}

	var out bytes.Buffer
	var errOut bytes.Buffer
	cmd := exec.Command("gofmt", f.Name())
	cmd.Stdout = &out
	cmd.Stderr = &errOut

	err = cmd.Run()

	if err != nil {
		keep = true
		return nil, errors.New(string(errOut.Bytes()))
	}

	return out.Bytes(), nil
}
