/**
 *  Copyright 2014 Paul Querna
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 *
 */

package generator

import (
	"bytes"
	"errors"
	"fmt"
	"github.com/pquerna/ffjson/shared"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
	"text/template"
)

const inceptionMainTemplate = `
// DO NOT EDIT!
// Code generated by ffjson <https://github.com/pquerna/ffjson>
// DO NOT EDIT!

package main

import (
	"github.com/pquerna/ffjson/inception"
	importedinceptionpackage "{{.ImportName}}"
)

func main() {
	i := ffjsoninception.NewInception("{{.InputPath}}", "{{.PackageName}}", "{{.OutputPath}}")
	i.AddMany(importedinceptionpackage.FFJSONExpose())
	i.Execute()
}
`

const ffjsonExposeTemplate = `
// Code generated by ffjson <https://github.com/pquerna/ffjson>
//
// This should be automatically deleted by running 'ffjson',
// if leftover, please delete it.

package {{.PackageName}}

import (
	"errors"
	fflib "github.com/pquerna/ffjson/fflib/v1"
)

func FFJSONExpose() []interface{} {
	rv := make([]interface{}, 0)
{{range .StructNames}}
	rv = append(rv, {{.}}{})
{{end}}
	return rv
}

{{range .StructNames}}
func (v *{{.}}) MarshalJSON() ([]byte, error) {
	return nil, errors.New("stub function")
}

func (v *{{.}}) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	return errors.New("stub function")
}

func (v *{{.}}) UnmarshalJSON(input []byte) error{
	return errors.New("stub function")
}

func (v *{{.}}) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	return errors.New("stub function")
}

{{end}}
`

type templateCtx struct {
	StructNames []string
	ImportName  string
	PackageName string
	InputPath   string
	OutputPath  string
}

type InceptionMain struct {
	goCmd        string
	inputPath    string
	exposePath   string
	outputPath   string
	TempMainPath string
	tempMain     *os.File
	tempExpose   *os.File
}

func NewInceptionMain(goCmd string, inputPath string, outputPath string) *InceptionMain {
	exposePath := getExposePath(inputPath)
	return &InceptionMain{
		goCmd:      goCmd,
		inputPath:  inputPath,
		outputPath: outputPath,
		exposePath: exposePath,
	}
}

func getImportName(inputPath string) (string, error) {
	p, err := filepath.Abs(inputPath)
	if err != nil {
		return "", err
	}

	dpath := filepath.Dir(p)

	gopaths := strings.Split(os.Getenv("GOPATH"), string(os.PathListSeparator))

	for _, path := range gopaths {
		gpath, err := filepath.Abs(path)
		if err != nil {
			continue
		}
		rel, err := filepath.Rel(filepath.ToSlash(gpath), dpath)
		if err != nil {
			return "", err
		}

		if len(rel) < 4 || rel[:4] != "src"+string(os.PathSeparator) {
			continue
		}
		return rel[4:], nil
	}
	return "", errors.New(fmt.Sprintf("Could not find source directory: GOPATH=%q REL=%q", gopaths, dpath))

}

func getExposePath(inputPath string) string {
	return inputPath[0:len(inputPath)-3] + "_ffjson_expose.go"
}

func (im *InceptionMain) renderTpl(f *os.File, t *template.Template, tc *templateCtx) error {
	err := t.Execute(f, tc)
	if err != nil {
		return err
	}

	out, err := shared.GoFmt(f.Name())
	if err != nil {
		return err
	}

	_, err = f.Seek(0, 0)
	if err != nil {
		return err
	}

	err = f.Truncate(0)
	if err != nil {
		return err
	}

	_, err = f.Write(out.Bytes())
	if err != nil {
		return err
	}

	return nil
}

func (im *InceptionMain) Generate(packageName string, si []*StructInfo) error {
	var err error

	importName, err := getImportName(im.inputPath)

	if err != nil {
		return err
	}

	importName = filepath.ToSlash(importName)
	// for `go run` to work, we must have a file ending in ".go".
	im.tempMain, err = TempFileWithPostfix("", "ffjson-inception", ".go")
	if err != nil {
		return err
	}

	im.TempMainPath = im.tempMain.Name()
	sn := make([]string, 0)
	for _, st := range si {
		sn = append(sn, st.Name)
	}

	tc := &templateCtx{
		ImportName:  importName,
		PackageName: packageName,
		StructNames: sn,
		InputPath:   im.inputPath,
		OutputPath:  im.outputPath,
	}

	t := template.Must(template.New("inception.go").Parse(inceptionMainTemplate))

	err = im.renderTpl(im.tempMain, t, tc)
	if err != nil {
		return err
	}

	im.tempExpose, err = os.Create(im.exposePath)
	if err != nil {
		return err
	}

	t = template.Must(template.New("ffjson_expose.go").Parse(ffjsonExposeTemplate))

	err = im.renderTpl(im.tempExpose, t, tc)
	if err != nil {
		return err
	}

	return nil
}

func (im *InceptionMain) Run() error {
	var out bytes.Buffer
	var errOut bytes.Buffer

	os.Remove(im.outputPath)

	cmd := exec.Command(im.goCmd, "run", "-a", im.TempMainPath)
	cmd.Stdout = &out
	cmd.Stderr = &errOut

	err := cmd.Run()

	if err != nil {
		return errors.New(
			fmt.Sprintf("Go Run Failed for: %s\nSTDOUT:\n%s\nSTDERR:\n%s\n",
				im.TempMainPath,
				string(out.Bytes()),
				string(errOut.Bytes())))
	}

	defer func() {
		if im.tempExpose != nil {
			im.tempExpose.Close()
		}

		if im.tempMain != nil {
			im.tempMain.Close()
		}

		os.Remove(im.TempMainPath)
		os.Remove(im.exposePath)
	}()

	return nil
}
